 напиши Базу данных, без каких либо хитрых алгоримтов и какой либо сложности. 
база данных должна быть представлена в виде одного хэдера (читать что такое " header only library " )

ты должен на выходе дать мне один файл - database.h, импортируя который я получу файловую клиентскую базу данных. 

я должен получить такие функции, как:
store(идентификатор, массив байтов) - сохраняет на компьютер массив байтов с переданным идентификатором 
load(идентификатор) - вернуть массив байтов, которые были сохранены по данному идентификатору, либо нулевой указатель
delete(идентификатор) - удалить байты по данному идентификатору

твоя база данных должны сохранять всё в файлы в некоторый каталог. путь до каталога должен устанавливать пользователь твой базы данных - например я. Без заданного пути Бд не должна работать. 

Размер одного файла, в котором будут хранится мои данные, должен задаваться либо мной, как и путь, либо должен быть определен по умолчанию - 8 мегабайт
естественно, для всех функций должны быть тесты

в общем, давай остановимся на функции
bool store(int id, void* data);
массив байтов и есть 2ой параметр
если хочешь более правильное решение, заиспользуй шаблон
template<typename T> 
bool store(int id, T* data);
я должен мочь 100 мегабайт засунуть
и эти 100 мегабайт
будут разбиты на 100 файлов
и тебе надо как-то понимать
из каких файлов потом читать
когда я сделаю load

To-Do list:
1) Написать хелперы
Список хелперов:
template <class T> 
bool store(int id, std::vector<T> const& data) { 
return true; 
} 

bool store_helper(int id, int data); 
bool store_helper(int id, double data); 
bool store_helper(int id, std::string const& data); 
bool store_helper(int id, std::vector<int> const& data); 
bool store_helper(int id, std::vector<double> const& data); 
bool store_helper(int id, std::vector<std::string> const& data);

2) Реализовать сохранение мапы в файл
3) Усовершествовать функцию удаления, чтобы файл удалялся полностью, если в данном файле кроме данных текущего id больше ничего нет
4) Написать тесты
5) Сделать функцию получения нового пути чистой